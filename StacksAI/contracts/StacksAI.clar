;; AI-Generated NFTs on Stacks
;; This contract implements NFTs that can be generated by AI and evolve over time
;; Metadata is stored on IPFS

;; Define the contract constants and variables
(define-constant contract-owner tx-sender)
(define-constant err-owner-only (err u100))
(define-constant err-not-token-owner (err u101))
(define-constant err-token-exists (err u102))
(define-constant err-token-not-found (err u103))
(define-constant err-invalid-token-id (err u104))
(define-constant err-invalid-uri (err u105))
(define-constant max-token-id u1000000) ;; Set a reasonable maximum token ID

;; Define the NFT token
(define-non-fungible-token ai-nft uint)

;; Data maps to store token metadata
(define-map token-metadata uint 
  {
    uri: (string-utf8 256),        ;; IPFS/Arweave URI for metadata
    creator: principal,            ;; Creator of the NFT
    created-at: uint,              ;; Block height when created
    last-evolved-at: uint,         ;; Block height when last evolved
    evolution-stage: uint          ;; Current evolution stage
  }
)

;; Data map to store evolution history
(define-map evolution-history 
  { token-id: uint, stage: uint } 
  { 
    uri: (string-utf8 256),        ;; IPFS/Arweave URI for this evolution stage
    evolved-at: uint               ;; Block height when evolved to this stage
  }
)

;; Helper function to validate URI format (basic check)
(define-private (is-valid-uri (uri (string-utf8 256)))
  (> (len uri) u0)
)

;; Helper function to validate token ID
(define-private (is-valid-token-id (token-id uint))
  (< token-id max-token-id)
)

;; Mint a new AI-generated NFT
(define-public (mint (token-id uint) (metadata-uri (string-utf8 256)))
  (let ((current-height stacks-block-height))
    ;; Validate inputs
    (asserts! (is-valid-token-id token-id) err-invalid-token-id)
    (asserts! (is-valid-uri metadata-uri) err-invalid-uri)
    (asserts! (is-eq tx-sender contract-owner) err-owner-only)
    (asserts! (is-none (nft-get-owner? ai-nft token-id)) err-token-exists)
    
    ;; Mint the NFT
    (try! (nft-mint? ai-nft token-id tx-sender))
    
    ;; Store the metadata
    (map-set token-metadata token-id {
      uri: metadata-uri,
      creator: tx-sender,
      created-at: current-height,
      last-evolved-at: current-height,
      evolution-stage: u0
    })
    
    ;; Store initial evolution state
    (map-set evolution-history 
      { token-id: token-id, stage: u0 } 
      { 
        uri: metadata-uri,
        evolved-at: current-height
      }
    )
    
    (ok token-id)
  )
)

;; Evolve an existing NFT to a new stage
(define-public (evolve-nft (token-id uint) (new-metadata-uri (string-utf8 256)))
  (begin
    ;; Validate inputs
    (asserts! (is-valid-token-id token-id) err-invalid-token-id)
    (asserts! (is-valid-uri new-metadata-uri) err-invalid-uri)
    (asserts! (is-eq tx-sender contract-owner) err-owner-only)
    
    (let (
      (token-owner (unwrap! (nft-get-owner? ai-nft token-id) err-token-not-found))
      (current-height stacks-block-height)
      (metadata (unwrap! (map-get? token-metadata token-id) err-token-not-found))
      (new-stage (+ (get evolution-stage metadata) u1))
    )
      ;; Update the token metadata
      (map-set token-metadata token-id (merge metadata {
        uri: new-metadata-uri,
        last-evolved-at: current-height,
        evolution-stage: new-stage
      }))
      
      ;; Store evolution history
      (map-set evolution-history 
        { token-id: token-id, stage: new-stage } 
        { 
          uri: new-metadata-uri,
          evolved-at: current-height
        }
      )
      
      (ok new-stage)
    )
  )
)

;; Transfer an NFT to a new owner
(define-public (transfer (token-id uint) (recipient principal))
  (begin
    ;; Validate token ID
    (asserts! (is-valid-token-id token-id) err-invalid-token-id)
    
    (let ((token-owner (unwrap! (nft-get-owner? ai-nft token-id) err-token-not-found)))
      (asserts! (is-eq tx-sender token-owner) err-not-token-owner)
      (try! (nft-transfer? ai-nft token-id tx-sender recipient))
      (ok true)
    )
  )
)

;; Read-only functions

;; Get token metadata - Fixed to return a consistent response type
(define-read-only (get-token-metadata (token-id uint))
  (begin
    (asserts! (is-valid-token-id token-id) (err err-invalid-token-id))
    (match (map-get? token-metadata token-id)
      metadata (ok {
        uri: (get uri metadata),
        creator: (get creator metadata),
        created-at: (get created-at metadata),
        last-evolved-at: (get last-evolved-at metadata),
        evolution-stage: (get evolution-stage metadata)
      })
      (err err-token-not-found)
    )
  )
)

;; Get evolution history for a specific stage
(define-read-only (get-evolution-stage (token-id uint) (stage uint))
  (begin
    (asserts! (is-valid-token-id token-id) (err err-invalid-token-id))
    (match (map-get? evolution-history { token-id: token-id, stage: stage })
      stage-data (ok {
        uri: (get uri stage-data),
        evolved-at: (get evolved-at stage-data)
      })
      (err err-token-not-found)
    )
  )
)

;; Get all evolution stages for a token (limited to 20 for practical reasons)
;; Simplified version that just returns the stage 0 evolution data
(define-read-only (get-evolution-history (token-id uint))
  (begin
    (asserts! (is-valid-token-id token-id) (err err-invalid-token-id))
    (match (map-get? evolution-history { token-id: token-id, stage: u0 })
      stage-data (ok {
        uri: (get uri stage-data),
        evolved-at: (get evolved-at stage-data)
      })
      (err err-token-not-found)
    )
  )
)

;; Get the owner of a token
(define-read-only (get-token-owner (token-id uint))
  (begin
    (asserts! (is-valid-token-id token-id) (err err-invalid-token-id))
    (match (nft-get-owner? ai-nft token-id)
      owner (ok owner)
      (err err-token-not-found)
    )
  )
)
